Index: lib/UE4/UE_4.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#include \"iostream\"\n#include \"tuple\"\n#include \"stack\"\n#include \"UE_4.h\"\n\nint binSearch(int a[], int length, int search){\n    int up=length-1;\n    int down=length;\n    int i = length-1;\n    while(a[i] != search){\n        std::cout << i << std::endl;\n        if(search < a[i]){\n            up = i;\n            i = i / 2;\n        } else if(search > a[i]){\n            i = (i + up)/2;\n        }\n    }\n    return i;\n}\n\n\nvoid swapb(int &a, int &b){\n    int helper = a;\n    a=b;\n    b = helper;\n}\n\n\nvoid bubblesortRev(int a[], int length){\n    for(int i = length; i >= 0; i--){\n        for(int j = 0; j<i; j++){\n            if(a[j] >= a[j+1]){\n                swapb(a[j],a[j+1]);\n            }\n        }\n\n    }\n}\n/* Laufzeit und Korrektheit: Bubblesort Reverse:\n * Laufzeit:Ann.: Laufzeit = Bubblesort = O(n^2)\n * \"Beweis\" zur Korrektheit:\n * BubblesortRev iteriert über zwei Schleifen mit den Indizes i und j welche\n * dabei jeweils einen Zeiger auf das Ende des Arrays a[] (Hier Index i) und auf den Anfang des Arrays\n * darstellen. Hierbei laufen i & j entgegengesetzt (i--; j++).\n * Die Worst-Case Betrachtung des Bubblesort-Reverse wäre, dass das gegegebene Array bereits absteigend\n * sortiert wäre. Auf der rechten Seite des Arrays entsteht ein sortiertes Sub-Array, welches durch den\n * Laufindex j gefüllt wird.\n *\n */\n\n\nvoid insertionSort(int a[], int length){\n    int key;\n    for(int i = 1; i < length; i++){ // Nehme das nächste rechte Element neben dem sortierten Subarray\n        key = a[i];\n        int j = i - 1;\n        while(j >= 0 && a[j] > key){\n            a[j+1] = a[j]; //Schiebe das Array nach rechts\n            j--;\n        }\n        a[j+1] = key;\n    }\n}\n\nvoid insertionSortRev(int a[], int length){\n    int key;\n    for(int i = length - 1; i > 0; i--){ // Rechts beginnen, Sorted Subarray ist also am Ende des Arrays\n        key = a[i]; // greife das Element auf dem i gerade steht\n        int j = i + 1; // nehme das Element rechts von i\n        while(j <= length && a[j] < key){ //\n            a[j-1] = a[j]; // Schiebe alles nach links\n            j++;\n        }\n        a[j-1] = key;\n    }\n}\n\n/*\n * Laufzeit und Korrektheit: Insertionsort-Reverse\n * Laufzeit: Ann.: Worst-Case Betrachtung gleich wie bei \"normalem\" Insertionsort => O(n^2)\n * Korrektheit: Am Ende des Arrays wächst das sortierte Subarray. Durch key = a[i] wird das\n * nächste linke Element gegriffen. Der Index j wird dabei auf den \"Anfang\" des sortierten Subarrays gesetzt\n * Solange nun der \"Key\" größer als das Element ist, auf welches der Laufindex \"j\" zeigt, wird das sortierte\n * Array um eine stelle nach links geschoben und der Zeiger \"j\" wird inkrementiert für den nächsten Vergleich.\n * Sobald entweder das Ende des Arrays erreicht wird, wird der Key ans Ende des Arrays gesetzt oder, falls\n * der Key kleiner als a[j] ist, wird der Key eine Stelle vor a[j], also an a[j-1] gesetzt.\n * */\n\n\nvoid swapq(int & a, int & b){\n    int helper = a;\n    a = b;\n    b = helper;\n}\n\nvoid preparePartition(int a[], int indexOfPivot, int lastIndexOfArray, int &p) {\n    /*Just for randomness -- Swap first with random index\n    std::random_device rand;\n    std::mt19937 gen(rand());\n    std::uniform_int_distribution<>dis(indexOfPivot, lastIndexOfArray);\n    int rnum = dis(gen);\n    swapq(a[indexOfPivot], a[rnum]);*/\n\n\n    int pivot=a[indexOfPivot];\n    p = indexOfPivot - 1;\n    for(int i = indexOfPivot; i <= lastIndexOfArray; i++){\n        if(a[i] <= pivot){\n            p++;\n            swapq(a[i], a[p]);\n        }\n    }\n    swapq(a[indexOfPivot], a[p]);\n\n\n}\n\n/* Laufzeit und Korrektheit:\n * Laufzeit: Worst-Case betrachtung O(n^2) (Annahme: mod. SelectionSort hat gleiche Laufzeit wie \"normaler\")\n * Korrekheit: Rekursiver Aufruf von QuickSort-Funktion. Nach Divide & Conquer Grundsatz:\n * Beim aufrufen von PreparePartition wird zu Beginn eine Zufallszahl errechnet, welche dann mit dem Element\n * an der Stelle des PivotElements vertauscht wird. Darauf hin startet der eigentliche ALgorithmus. Es\n * Es wird Laufvariable i verwendet, welche mit dem Pivot-Index initialisiert wird, dazu kommt eine\n * weietere Variable p welche mittels Referenz übergeben wird. Beim Durchlaufen des Arrays durch die\n * Laufvariable i wird jedes Mal verglichen ob a[i] <= Pivot ist. Ist dies der Fall wird p inkrementiert.\n * p läuft dabei im optimal-Fall gemeinsam mit i durch das Array. Sollte der Fall auftreten, dass\n * a[i] > pivot sein, so wird nur i inkrementiert. Da p mindestens i-1 zu Beginn des nächsten\n * Schleifendurchlaufes ist, läuft i weiter durch das Array. Sobald das nächste Element gefunden wird,\n * welches <= als das Pivot ist, wird p wieder inkrementiert (p steht nach Inkrement nun auf dem\n * Index des Elementes welches größer als das Pivot ist. Nun wird a[i] und a[p] getauscht.\n * Nach dem die Schleife terminiert, wird das Pivot an die aktuelleste Stelle p getauscht.\n */\n\nvoid quicksort(int a[], int firstIndex, int lastIndex){\n    int part;\n    if(firstIndex < lastIndex){\n        preparePartition(a, firstIndex, lastIndex, part);\n        quicksort(a, firstIndex, part - 1);\n        quicksort(a, part+1, lastIndex);\n\n    }\n\n}\n\nvoid selectionSort(int a[], int length){\n    int i, j, max;\n    for(int i = length-1; i >= 0; i--){\n        max = i;\n        for(int j = i; j >= 0; j--){\n            if(a[max] < a[j]){\n                max = j;\n            }\n\n        }\n        int helper = a[max];\n        a[max] = a[i];\n        a[i] = helper;\n    }\n}\n\n/* Laufzeit & Korrektheit:\n * Laufzeit: Best,Average & Worst-Case = O(n^2) (Es wird jedes Element mit jedem Element verglichen)\n * Korrektheit: SelectionSort hat wird über zwei geschachtelte For-Loops realisiert.\n * Im ersten Durchgang haben dabei beide Laufindizes den selben Wert. Der Laufindex i gibt dabei maßgeblich\n * den Start welcher hier von rechts beginnt, an. Die Laufvariable j läuft dabei von i bis 0 und vergleicht\n * dabei den Startwert a[i] mit jedem anderen Wert über den die innere Schleife iteriert.\n * Wird ein Wert mit Index j gefunden, welche größer als das derzeitige Maximum\n * (initialisierung auf i), so bekommt die Varibale \"max\" entsprechend j zugewiesen. Nachdem die innere\n * Schleife terminiert wird in jedem Fall ein Austausch der Werte von a[i] und a[max] durchgeführt.\n * Sollte kein Element gefunden werden, welches größer als a[i] ist, wird a[i] mit a[max] getautscht werden.\n * Da max = 1 zu beginn der äußeren For-Loop initialisiert wird, wird i mit sich selbst getauscht\n * */\n\nvoid Merge(int a[],int f,int l,int m) {\n    int i;\n    int n = l - f + 1; // Calculate the size of the array\n    int a1f = f, a1l = m-1; // Calculate the first and last index of the left array\n    int a2f = m, a2l = l; // Calculate the first and last index of the right array\n    int *anew = new int[n]; // Reserve Memory for extra array\n    for (i = 0; i < n; i++) // Iterate over the array\n    {\n        if (a1f <= a1l) { // Ist der letzte Index größer gleich als der erste? vom linken array\n            if (a2f <= a2l){ // ist der letzte Index größer gleich als der Erste? vom rechten array\n                if (a[a1f] <= a[a2f]) // Ist der erste Index vom linken array kleiner/gleich dem des rechten?\n                    anew[i]=a[a1f++]; // Dann setze das anew[i] den Wert vom linken array, dann schiebe pointer weiter\n                else anew[i]=a[a2f++]; // Wenn nicht dann nehme den Wert vom rechten Array\n            }\n            else anew[i]=a[a1f++]; } // Es gibt nur ein Element in dem ganzen Array => sortiere ein ?\n        else anew[i]=a[a2f++]; }\n    for (i=0;i<n;i++)\n        a[f+i]=anew[i]; // Platziere den Inhalt an die richtige Stelle in a[]\n    delete [] anew; // Gib Speicherplatz wieder frei\n}\n\nvoid MergeSort(int a[],int f,int l){\n    if (f<l) { // Rufe die Funktion solange bis nur noch ein Element im Array ist.\n        int m = (f+l+1)/2;\n        MergeSort(a, f,m-1);\n        MergeSort(a,m, l);\n        Merge(a,f,l,m);\n    }\n}\n\nbool findS(int a[], int length, int s){\n    int leftpointer = 0;\n    int rightpointer = length;\n    while(leftpointer <= rightpointer){\n        if(a[leftpointer] + a[rightpointer] > s){\n            rightpointer--;\n        } else if(a[leftpointer] + a[rightpointer] < s){\n            leftpointer++;\n        }\n        else if(a[leftpointer]+a[rightpointer]==s){\n            std::cout << leftpointer << \" \" << rightpointer << std::endl;\n            return true;\n        }\n    }\n    return false;\n}\n\nvoid insertionSort_rec(int a[], int length, int i) {\n    if (i < length) {\n        int key = a[i];\n        int j = i - 1; // j ist der index um durch das Sortierte Array zu iterieren\n        while (j >= 0 && key < a[j]) {\n            a[j + 1] = a[j];\n            j--;\n        }\n        a[j + 1] = key;\n        insertionSort_rec(a, length, i + 1);\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/lib/UE4/UE_4.cpp b/lib/UE4/UE_4.cpp
--- a/lib/UE4/UE_4.cpp	
+++ b/lib/UE4/UE_4.cpp	
@@ -203,6 +203,7 @@
 }
 
 bool findS(int a[], int length, int s){
+    // Um n log(n) zu garantieren muss das Array durch MergeSort vorsortiert sein.
     int leftpointer = 0;
     int rightpointer = length;
     while(leftpointer <= rightpointer){
